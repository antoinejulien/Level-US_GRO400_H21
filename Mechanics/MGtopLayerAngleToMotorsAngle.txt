% MotionGenesis file:  MGTemplateBasic.txt
% Copyright (mot2) 2009-2020 Motion Genesis LLC.  Only for use with MotionGenesis.
%--------------------------------------------------------------------
%   Physical objects.
NewtonianFrame  plaqueBas                % Newtonian reference frame
RigidBody       mot1,mot2,mot3,	Bras1Debut,Bras2Debut,Bras3Debut,	Bras1Fin,Bras2Fin,Bras3Fin,	PlaqueTop  
%plaqueBas = plaque bas
%BCD = moteur
%EFG = bras 1
%HLM = bras 2
%NOP = joint pivot
%PlaqueTop = plaque top
Point           posMot1(plaqueBas),posMot2(plaqueBas),posMot3(plaqueBas)		%plaque bas

Point			axeMot1(mot1),axeMot2(mot2),axeMot3(mot3)		%moteurs
	
Point			bras1Middle(Bras1Debut),bras2Middle(Bras2Debut),bras3Middle(Bras3Debut)		%Bras 1
	
Point			bras1End(Bras1Fin),bras2End(Bras2Fin),bras3End(Bras3Fin)		%Bras 2 

Point			P1Plaque(PlaqueTop),P2Plaque(PlaqueTop),P3Plaque(PlaqueTop)		%plaque top % 


%--------------------------------------------------------------------
%   Mathematical declarations.

Variable	angleBras1Middle'',angleBras2Middle'',angleBras3Middle''			%angle bras 2

choice = 1 	% 1= positionPlaqueInputAngleMoteurOutput
			% 2= positionAngleMoteurInputPlaqueOutput
if(choice == 1){
	Variable   	angleMot1'',angleMot2'',angleMot3''			%angle bras 1
	specified 	anglePlaqueTop_x'',anglePlaqueTop_y'',anglePlaqueTop_z''      	%angle plaque top
	%specified	eR0'',eR1'',eR2'',eR3''
	specified 	distancePlaqueTop_x'',distancePlaqueTop_y'',hauteurPlaqueTop''		%position des centres de masse de la plaque du haut par rapport plaque du bas
}
if(choice == 2){
	specified  	angleMot1'',angleMot2'',angleMot3''			%angle bras 1
	variable 	anglePlaqueTop_x'',anglePlaqueTop_y'',anglePlaqueTop_z''      	%angle plaque top
	Variable 	distancePlaqueTop_x'',distancePlaqueTop_y'',hauteurPlaqueTop''		%position plaque du haut par rapport plaque du bas
}


constant	rayonDistanceAncrage = 133.33 mm	%distance entre Bras2Fin'ancrage de la plaque du haut et du pivot par rapport au centre de masse de la plaque
constant 	rayonDistanceMoteur = (133.33+15) mm
constant	hauteurAxeMoteur = 28.63 mm
constant 	longueurBras1 = 3 in
constant	longueurBras2 = 4 in
constant	rayonDistanceAncrageEtPivot = (133.33+15) mm


%--------------------------------------------------------------------

%   Mass and inertia properties.
%PlaqueTop.SetMass(mR = 44.39 grams)
%chargeAppliquerSurPlaque.setMass(masseCharge)
%PlaqueTop.setInertia(Rcm, IRxx = 78730.95 grams*mm^2 , IRyy = 78730.95 grams*mm^2, IRzz = 157163.35 grams*mm^2)

%--------------------------------------------------------------------
%   Rotational kinematics.
mot1.RotateZ(plaqueBas, 0*ConvertUnits(deg,rad))
mot2.RotateZ(plaqueBas, -120*ConvertUnits(deg,rad))
mot3.RotateZ(plaqueBas, 120*ConvertUnits(deg,rad))

Bras1Debut.RotateX(mot1,-angleMot1)
Bras2Debut.RotateX(mot2,-angleMot2)
Bras3Debut.RotateX(mot3,-angleMot3)

Bras1Fin.RotateX(Bras1Debut,-angleBras1Middle)
Bras2Fin.RotateX(Bras2Debut,-angleBras2Middle)
Bras3Fin.RotateX(Bras3Debut,-angleBras3Middle)

PlaqueTop.Rotate(plaqueBas,bodyXYZ,anglePlaqueTop_x,anglePlaqueTop_y,anglePlaqueTop_z)
%PlaqueTop.setRotationMatrixODE(plaqueBas,Euler,eR0,eR1,eR2,eR3)


%--------------------------------------------------------------------
%   Translational kinematics.
posMot1.Translate(PlaqueBaso,rayonDistanceMoteur*plaqueBasy>)															%position moteur 1
posMot2.Translate(PlaqueBaso,rayonDistanceMoteur*cosDegrees(30)*plaqueBasx> - rayonDistanceMoteur*sinDegrees(30)*plaqueBasy>)	%position moteur 2
posMot3.Translate(PlaqueBaso,-rayonDistanceMoteur*cosDegrees(30)*plaqueBasx> - rayonDistanceMoteur*sinDegrees(30)*plaqueBasy>)	%position moteur 3

axeMot1.translate(posMot1, hauteurAxeMoteur*mot1z>)
axeMot2.translate(posMot2, hauteurAxeMoteur*mot2z>)
axeMot3.translate(posMot3, hauteurAxeMoteur*mot3z>)

bras1Middle.translate(axeMot1, longueurBras1*Bras1Debuty>)
bras2Middle.translate(axeMot2, longueurBras1*Bras2Debuty>)
bras3Middle.translate(axeMot3, longueurBras1*Bras3Debuty>)

bras1End.translate(bras1Middle, -longueurBras2*Bras1Finy>)
bras2End.translate(bras2Middle, -longueurBras2*Bras2Finy>)
bras3End.translate(bras3Middle, -longueurBras2*Bras3Finy>)



PlaqueTopo.translate(PlaqueBaso, distancePlaqueTop_x*plaqueBasx> + distancePlaqueTop_y*plaqueBasy> + hauteurPlaqueTop*plaqueBasz>)
P1Plaque.translate(PlaqueTopo, rayonDistanceAncrageEtPivot*plaqueTopy>)
P2Plaque.translate(PlaqueTopo,rayonDistanceAncrageEtPivot*cosDegrees(30)*plaqueTopx> - rayonDistanceAncrageEtPivot*sinDegrees(30)*plaqueTopy>)	
P3Plaque.translate(PlaqueTopo,-rayonDistanceAncrageEtPivot*cosDegrees(30)*plaqueTopx> - rayonDistanceAncrageEtPivot*sinDegrees(30)*plaqueTopy>)


%--------------------------------------------------------------------
%   Motion constraints (if any).
contrainte[1] = bras1End.GetPosition(PlaqueBaso)-P1Plaque.GetPosition(PlaqueBaso)
contrainte[2] = bras2End.GetPosition(PlaqueBaso)-P2Plaque.GetPosition(PlaqueBaso)
contrainte[3] = bras3End.GetPosition(PlaqueBaso)-P3Plaque.GetPosition(PlaqueBaso)

MotionConstraint[1] = dot(contrainte[1],plaqueBasx>)
MotionConstraint[2] = dot(contrainte[1],plaqueBasy>)
MotionConstraint[3] = dot(contrainte[1],plaqueBasz>)

MotionConstraint[4] = dot(contrainte[2],plaqueBasx>)
MotionConstraint[5] = dot(contrainte[2],plaqueBasy>)
MotionConstraint[6] = dot(contrainte[2],plaqueBasz>)

MotionConstraint[7] = dot(contrainte[3],plaqueBasx>)
MotionConstraint[8] = dot(contrainte[3],plaqueBasy>)
MotionConstraint[9] = dot(contrainte[3],plaqueBasz>)


%--------------------------------------------------------------------
%   Add relevant contact/distance forces.

%chargeAppliquerSurPlaque.AddForce(-Bras3Debut*masseCharge*Az>)

%pause

%--------------------------------------------------------------------

%--------------------------------------------------------------------
%   Solve algebraic equations for list of unknowns.
%Solve( [Dynamics;motionconstraint],qA'',qB'',X'',Fx,Fz,Fwx,Fwz )

% 1= positionPlaqueInputAngleMoteurOutput
% 2= positionAngleMoteurInputPlaqueOutput
if(choice == 1){
% on veut avoir comme reponse hauteurPlaqueTop, anglePlaqueTop_x et anglePlaqueTop_y
	%output angleMot1 deg, angleMot2 deg, angleMot3 deg
	
	solve( [motionconstraint], distancePlaqueTop_x , distancePlaqueTop_y , hauteurPlaqueTop , anglePlaqueTop_x , anglePlaqueTop_y , anglePlaqueTop_z , angleBras1Middle , angleBras2Middle , angleBras3Middle)
	%Code Algebraic() positionMoteurInputPlaqueOutputAngle.Bras3Fin([motionconstraint], distancePlaqueTop_x , distancePlaqueTop_y , hauteurPlaqueTop , anglePlaqueTop_x , anglePlaqueTop_y , anglePlaqueTop_z , angleBras1Middle , angleBras2Middle , angleBras3Middle)
	
	quit
}
if(choice == 2){
	quit
}



%--------------------------------------------------------------------
%   Initial values for variables (Bras1Debut.Bras3Debut., for ODE command).
%Input  	qA = 0  	deg, 	 qA' = 0	deg/sec	%'roue
%Input  	qB = 5  	deg, 	 qB' = 0 	deg/sec %'pendule
%input 	X  = 0  	Bras3Fin,  	 X'  = 0.00 	Bras3Fin/s %'


%--------------------------------------------------------------------
% %   Other calculations (distance, energy, momentum, etc.).
% xQ = Dot(  Q.GetPosition(No),  Nx>  )
% KE = System.GetKineticEnergy()
% PEgravity = System.GetForceGravityPotentialEnergy( -Bras3Debut*Ny>, No )
% MechanicalEnergy = KE + PEgravity
% Bras1Fin> = System.GetAngularMomentum( aboutPoint )
% Bras2Fin> = EvaluateToNumber( System.GetLinearMomentum() )
%--------------------------------------------------------------------
%   List output quantities (Bras1Debut.Bras3Debut., for ODE command).
% Output      t sec,  x Bras3Fin,  Fx Newton,  Fy Newton
% OutputPlot  t sec,  qA degrees,  qB degrees, X mm%, An.getdistance(No) mm, Tmot N/Bras3Fin
% variable xtip = dot(Nx>,Bc.getposition(No))
% variable ztip = dot(Nz>,Bc.getposition(No))

% outputEncode x Bras3Fin, qA deg, qB deg,x' Bras3Fin/s, qA' deg/s, qB' deg/s, x'' Bras3Fin/sec^2, qA'' deg/sec^2, qB'' deg/sec^2

% Code Algebraic() RobotSimulink.Bras3Fin( x Bras3Fin, qA deg, qB deg, x' Bras3Fin/s, qA' deg/s, qB' deg/s,Tmot N/Bras3Fin, mC, zplex)%'
%output t sec, x Bras3Fin, xtip Bras3Fin,ztip Bras3Fin
%[Dynamics;motionconstraint],qA'',qB'',X'',Fx,Fz,Fwx,Fwz
%--------------------------------------------------------------------
%   Solve ODEs (or auto-generate MATLAB, mot2, Fortran, ... code).

%Input  tFinal = 1 sec,  tStep = 0.01 sec,  absError = 1.0E-08
%ODE([Dynamics;motionconstraint],qA'',qB'',X'',Fx,Fz,Fwx,Fwz)  DynamiqueRobot.Bras3Fin 
%--------------------------------------------------------------------
%   Record input together with responses.
% Save  DynamiqueRobot.html
Quit

