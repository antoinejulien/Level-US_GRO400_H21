   (1) % MotionGenesis file:  MGTemplateBasic.txt
   (2) % Copyright (mot2) 2009-2020 Motion Genesis LLC.  Only for use with MotionGenesis.
   (3) %--------------------------------------------------------------------
   (4) %   Physical objects.
   (5) NewtonianFrame  plaqueBas                % Newtonian reference frame
   (6) RigidBody       mot1,mot2,mot3,	Bras1Debut,Bras2Debut,Bras3Debut,	Bras1Fin,Bras2Fin,Bras3Fin,	PlaqueTop  
   (7) %plaqueBas = plaque bas
   (8) %BCD = moteur
   (9) %EFG = bras 1
   (10) %HLM = bras 2
   (11) %NOP = joint pivot
   (12) %PlaqueTop = plaque top
   (13) Point           posMot1(plaqueBas),posMot2(plaqueBas),posMot3(plaqueBas)		%plaque bas
   (14) Point			axeMot1(mot1),axeMot2(mot2),axeMot3(mot3)		%moteurs
   (15) Point			bras1Middle(Bras1Debut),bras2Middle(Bras2Debut),bras3Middle(Bras3Debut)		%Bras 1
   (16) Point			bras1End(Bras1Fin),bras2End(Bras2Fin),bras3End(Bras3Fin)		%Bras 2 
   (17) Point			P1Plaque(PlaqueTop),P2Plaque(PlaqueTop),P3Plaque(PlaqueTop)		%plaque top % 
   (18) %--------------------------------------------------------------------
   (19) %   Mathematical declarations.
   (20) Variable	angleBras1Middle'',angleBras2Middle'',angleBras3Middle''			%angle bras 2
   (21) choice = 1 	% 1= positionPlaqueInputAngleMoteurOutput
-> (22) choice = 1

   (23) % 2= positionAngleMoteurInputPlaqueOutput
   (24) Variable   	angleMot1'',angleMot2'',angleMot3''			%angle bras 1
   (25) specified 	anglePlaqueTop_x'',anglePlaqueTop_y''      	%angle plaque top
   (26) %specified	eR0'',eR1'',eR2'',eR3''
   (27) specified 	hauteurPlaqueTop''		%position des centres de masse de la plaque du haut par rapport plaque du bas
   (28) Variable 	anglePlaqueTop_z'', distancePlaqueTop_x'',distancePlaqueTop_y''
   (29) constant	rayonDistanceAncrage = 133.33 mm	%distance entre Bras2Fin'ancrage de la plaque du haut et du pivot par rapport au centre de masse de la plaque
   (30) constant 	rayonDistanceMoteur = (133.33+15) mm
   (31) constant	hauteurAxeMoteur = 28.63 mm
   (32) constant 	longueurBras1 = 3 in
   (33) constant	longueurBras2 = 4 in
   (34) constant	rayonDistanceAncrageEtPivot = (133.33+15) mm
   (35) %--------------------------------------------------------------------
   (36) %   Mass and inertia properties.
   (37) %PlaqueTop.SetMass(mR = 44.39 grams)
   (38) %chargeAppliquerSurPlaque.setMass(masseCharge)
   (39) %PlaqueTop.setInertia(Rcm, IRxx = 78730.95 grams*mm^2 , IRyy = 78730.95 grams*mm^2, IRzz = 157163.35 grams*mm^2)
   (40) %--------------------------------------------------------------------
   (41) %   Rotational kinematics.
   (42) mot1.RotateZ(plaqueBas, 0*ConvertUnits(deg,rad))
-> (43) mot1_plaqueBas = [1, 0, 0;  0, 1, 0;  0, 0, 1]
-> (44) w_mot1_plaqueBas> = 0>
-> (45) alf_mot1_plaqueBas> = 0>

   (46) mot2.RotateZ(plaqueBas, -120*ConvertUnits(deg,rad))
-> (47) mot2_plaqueBas = [-0.5, -0.8660254, 0;  0.8660254, -0.5, 0;  0, 0, 1]
-> (48) w_mot2_plaqueBas> = 0>
-> (49) alf_mot2_plaqueBas> = 0>

   (50) mot3.RotateZ(plaqueBas, 120*ConvertUnits(deg,rad))
-> (51) mot3_plaqueBas = [-0.5, 0.8660254, 0;  -0.8660254, -0.5, 0;  0, 0, 1]
-> (52) w_mot3_plaqueBas> = 0>
-> (53) alf_mot3_plaqueBas> = 0>

   (54) Bras1Debut.RotateX(mot1,angleMot1)
-> (55) Bras1Debut_mot1 = [1, 0, 0;  0, cos(angleMot1), sin(angleMot1);  0, -sin(angleMot1), cos(angleMot1)]
-> (56) w_Bras1Debut_mot1> = angleMot1'*Bras1Debutx>
-> (57) w_Bras1Debut_plaqueBas> = angleMot1'*Bras1Debutx>
-> (58) alf_Bras1Debut_mot1> = angleMot1''*Bras1Debutx>
-> (59) alf_Bras1Debut_plaqueBas> = angleMot1''*Bras1Debutx>

   (60) Bras2Debut.RotateX(mot2,angleMot2)
-> (61) Bras2Debut_mot2 = [1, 0, 0;  0, cos(angleMot2), sin(angleMot2);  0, -sin(angleMot2), cos(angleMot2)]
-> (62) w_Bras2Debut_mot2> = angleMot2'*Bras2Debutx>
-> (63) w_Bras2Debut_plaqueBas> = angleMot2'*Bras2Debutx>
-> (64) alf_Bras2Debut_mot2> = angleMot2''*Bras2Debutx>
-> (65) alf_Bras2Debut_plaqueBas> = angleMot2''*Bras2Debutx>

   (66) Bras3Debut.RotateX(mot3,angleMot3)
-> (67) Bras3Debut_mot3 = [1, 0, 0;  0, cos(angleMot3), sin(angleMot3);  0, -sin(angleMot3), cos(angleMot3)]
-> (68) w_Bras3Debut_mot3> = angleMot3'*Bras3Debutx>
-> (69) w_Bras3Debut_plaqueBas> = angleMot3'*Bras3Debutx>
-> (70) alf_Bras3Debut_mot3> = angleMot3''*Bras3Debutx>
-> (71) alf_Bras3Debut_plaqueBas> = angleMot3''*Bras3Debutx>

   (72) Bras1Fin.RotateX(Bras1Debut,-angleBras1Middle)
-> (73) Bras1Fin_Bras1Debut = [1, 0, 0;  0, cos(angleBras1Middle), -sin(angleB
        ras1Middle);  0, sin(angleBras1Middle), cos(angleBras1Middle)]

-> (74) w_Bras1Fin_Bras1Debut> = -angleBras1Middle'*Bras1Finx>
-> (75) w_Bras1Fin_plaqueBas> = (angleMot1'-angleBras1Middle')*Bras1Debutx>
-> (76) alf_Bras1Fin_Bras1Debut> = -angleBras1Middle''*Bras1Finx>
-> (77) alf_Bras1Fin_plaqueBas> = (angleMot1''-angleBras1Middle'')*Bras1Debutx>

   (78) Bras2Fin.RotateX(Bras2Debut,-angleBras2Middle)
-> (79) Bras2Fin_Bras2Debut = [1, 0, 0;  0, cos(angleBras2Middle), -sin(angleB
        ras2Middle);  0, sin(angleBras2Middle), cos(angleBras2Middle)]

-> (80) w_Bras2Fin_Bras2Debut> = -angleBras2Middle'*Bras2Finx>
-> (81) w_Bras2Fin_plaqueBas> = (angleMot2'-angleBras2Middle')*Bras2Debutx>
-> (82) alf_Bras2Fin_Bras2Debut> = -angleBras2Middle''*Bras2Finx>
-> (83) alf_Bras2Fin_plaqueBas> = (angleMot2''-angleBras2Middle'')*Bras2Debutx>

   (84) Bras3Fin.RotateX(Bras3Debut,-angleBras3Middle)
-> (85) Bras3Fin_Bras3Debut = [1, 0, 0;  0, cos(angleBras3Middle), -sin(angleB
        ras3Middle);  0, sin(angleBras3Middle), cos(angleBras3Middle)]

-> (86) w_Bras3Fin_Bras3Debut> = -angleBras3Middle'*Bras3Finx>
-> (87) w_Bras3Fin_plaqueBas> = (angleMot3'-angleBras3Middle')*Bras3Debutx>
-> (88) alf_Bras3Fin_Bras3Debut> = -angleBras3Middle''*Bras3Finx>
-> (89) alf_Bras3Fin_plaqueBas> = (angleMot3''-angleBras3Middle'')*Bras3Debutx>

   (90) PlaqueTop.Rotate(plaqueBas,bodyXYZ,anglePlaqueTop_x,anglePlaqueTop_y,anglePlaqueTop_z)
-> (91) PlaqueTop_plaqueBas[1,1] = cos(anglePlaqueTop_y)*cos(anglePlaqueTop_z)
-> (92) PlaqueTop_plaqueBas[1,2] = cos(anglePlaqueTop_x)*sin(anglePlaqueTop_z)
        + sin(anglePlaqueTop_x)*sin(anglePlaqueTop_y)*cos(anglePlaqueTop_z)

-> (93) PlaqueTop_plaqueBas[1,3] = sin(anglePlaqueTop_x)*sin(anglePlaqueTop_z)
        - sin(anglePlaqueTop_y)*cos(anglePlaqueTop_x)*cos(anglePlaqueTop_z)

-> (94) PlaqueTop_plaqueBas[2,1] = -cos(anglePlaqueTop_y)*sin(anglePlaqueTop_z)
-> (95) PlaqueTop_plaqueBas[2,2] = cos(anglePlaqueTop_x)*cos(anglePlaqueTop_z)
        - sin(anglePlaqueTop_x)*sin(anglePlaqueTop_y)*sin(anglePlaqueTop_z)

-> (96) PlaqueTop_plaqueBas[2,3] = sin(anglePlaqueTop_x)*cos(anglePlaqueTop_z)
        + sin(anglePlaqueTop_y)*cos(anglePlaqueTop_x)*sin(anglePlaqueTop_z)

-> (97) PlaqueTop_plaqueBas[3,1] = sin(anglePlaqueTop_y)
-> (98) PlaqueTop_plaqueBas[3,2] = -sin(anglePlaqueTop_x)*cos(anglePlaqueTop_y)
-> (99) PlaqueTop_plaqueBas[3,3] = cos(anglePlaqueTop_x)*cos(anglePlaqueTop_y)
-> (100) w_PlaqueTop_plaqueBas> = (anglePlaqueTop_y'*sin(anglePlaqueTop_z)+cos(
         anglePlaqueTop_y)*anglePlaqueTop_x'*cos(anglePlaqueTop_z))*PlaqueTopx>
         + (anglePlaqueTop_y'*cos(anglePlaqueTop_z)-cos(anglePlaqueTop_y)*angl
         ePlaqueTop_x'*sin(anglePlaqueTop_z))*PlaqueTopy> + (sin(anglePlaqueTo
         p_y)*anglePlaqueTop_x'+anglePlaqueTop_z')*PlaqueTopz>

-> (101) alf_PlaqueTop_plaqueBas> = (anglePlaqueTop_y''*sin(anglePlaqueTop_z)+
         cos(anglePlaqueTop_y)*anglePlaqueTop_x''*cos(anglePlaqueTop_z)+angleP
         laqueTop_y'*cos(anglePlaqueTop_z)*anglePlaqueTop_z'-sin(anglePlaqueTo
         p_y)*anglePlaqueTop_x'*anglePlaqueTop_y'*cos(anglePlaqueTop_z)-cos(an
         glePlaqueTop_y)*anglePlaqueTop_x'*sin(anglePlaqueTop_z)*anglePlaqueTo
         p_z')*PlaqueTopx> + (anglePlaqueTop_y''*cos(anglePlaqueTop_z)+sin(ang
         lePlaqueTop_y)*anglePlaqueTop_x'*anglePlaqueTop_y'*sin(anglePlaqueTop
         _z)-cos(anglePlaqueTop_y)*anglePlaqueTop_x''*sin(anglePlaqueTop_z)-an
         glePlaqueTop_y'*sin(anglePlaqueTop_z)*anglePlaqueTop_z'-cos(anglePlaq
         ueTop_y)*anglePlaqueTop_x'*cos(anglePlaqueTop_z)*anglePlaqueTop_z')*PlaqueTopy>
         + (cos(anglePlaqueTop_y)*anglePlaqueTop_x'*anglePlaqueTop_y'+sin(angl
         ePlaqueTop_y)*anglePlaqueTop_x''+anglePlaqueTop_z'')*PlaqueTopz>

   (102) %PlaqueTop.setRotationMatrixODE(plaqueBas,Euler,eR0,eR1,eR2,eR3)
   (103) %--------------------------------------------------------------------
   (104) %   Translational kinematics.
   (105) posMot1.Translate(PlaqueBaso,rayonDistanceMoteur*plaqueBasy>)															%position moteur 1
-> (106) p_plaqueBaso_posMot1> = rayonDistanceMoteur*plaqueBasy>
-> (107) v_posMot1_plaqueBas> = 0>
-> (108) a_posMot1_plaqueBas> = 0>

   (109) posMot2.Translate(PlaqueBaso,rayonDistanceMoteur*cosDegrees(30)*plaqueBasx> - rayonDistanceMoteur*sinDegrees(30)*plaqueBasy>)	%position moteur 2
-> (110) p_plaqueBaso_posMot2> = 0.8660254*rayonDistanceMoteur*plaqueBasx> - 0.5*rayonDistanceMoteur*plaqueBasy>
-> (111) v_posMot2_plaqueBas> = 0>
-> (112) a_posMot2_plaqueBas> = 0>

   (113) posMot3.Translate(PlaqueBaso,-rayonDistanceMoteur*cosDegrees(30)*plaqueBasx> - rayonDistanceMoteur*sinDegrees(30)*plaqueBasy>)	%position moteur 3
-> (114) p_plaqueBaso_posMot3> = -0.8660254*rayonDistanceMoteur*plaqueBasx> - 0.5*rayonDistanceMoteur*plaqueBasy>
-> (115) v_posMot3_plaqueBas> = 0>
-> (116) a_posMot3_plaqueBas> = 0>

   (117) axeMot1.translate(posMot1, hauteurAxeMoteur*mot1z>)
-> (118) p_posMot1_axeMot1> = hauteurAxeMoteur*mot1z>
-> (119) v_axeMot1_plaqueBas> = 0>
-> (120) a_axeMot1_plaqueBas> = 0>

   (121) axeMot2.translate(posMot2, hauteurAxeMoteur*mot2z>)
-> (122) p_posMot2_axeMot2> = hauteurAxeMoteur*mot2z>
-> (123) v_axeMot2_plaqueBas> = 0>
-> (124) a_axeMot2_plaqueBas> = 0>

   (125) axeMot3.translate(posMot3, hauteurAxeMoteur*mot3z>)
-> (126) p_posMot3_axeMot3> = hauteurAxeMoteur*mot3z>
-> (127) v_axeMot3_plaqueBas> = 0>
-> (128) a_axeMot3_plaqueBas> = 0>

   (129) bras1Middle.translate(axeMot1, longueurBras1*Bras1Debuty>)
-> (130) p_axeMot1_bras1Middle> = longueurBras1*Bras1Debuty>
-> (131) v_bras1Middle_plaqueBas> = longueurBras1*angleMot1'*Bras1Debutz>
-> (132) a_bras1Middle_plaqueBas> = -longueurBras1*angleMot1'^2*Bras1Debuty> + longueurBras1*angleMot1''*Bras1Debutz>

   (133) bras2Middle.translate(axeMot2, longueurBras1*Bras2Debuty>)
-> (134) p_axeMot2_bras2Middle> = longueurBras1*Bras2Debuty>
-> (135) v_bras2Middle_plaqueBas> = longueurBras1*angleMot2'*Bras2Debutz>
-> (136) a_bras2Middle_plaqueBas> = -longueurBras1*angleMot2'^2*Bras2Debuty> + longueurBras1*angleMot2''*Bras2Debutz>

   (137) bras3Middle.translate(axeMot3, longueurBras1*Bras3Debuty>)
-> (138) p_axeMot3_bras3Middle> = longueurBras1*Bras3Debuty>
-> (139) v_bras3Middle_plaqueBas> = longueurBras1*angleMot3'*Bras3Debutz>
-> (140) a_bras3Middle_plaqueBas> = -longueurBras1*angleMot3'^2*Bras3Debuty> + longueurBras1*angleMot3''*Bras3Debutz>

   (141) bras1End.translate(bras1Middle, -longueurBras2*Bras1Finy>)
-> (142) p_bras1Middle_bras1End> = -longueurBras2*Bras1Finy>
-> (143) v_bras1End_plaqueBas> = longueurBras1*angleMot1'*Bras1Debutz> + longu
         eurBras2*(angleBras1Middle'-angleMot1')*Bras1Finz>

-> (144) a_bras1End_plaqueBas> = -longueurBras1*angleMot1'^2*Bras1Debuty>
         + longueurBras1*angleMot1''*Bras1Debutz> + longueurBras2*(angleBras1M
         iddle'-angleMot1')^2*Bras1Finy> + longueurBras2*(angleBras1Middle''-
         angleMot1'')*Bras1Finz>

   (145) bras2End.translate(bras2Middle, -longueurBras2*Bras2Finy>)
-> (146) p_bras2Middle_bras2End> = -longueurBras2*Bras2Finy>
-> (147) v_bras2End_plaqueBas> = longueurBras1*angleMot2'*Bras2Debutz> + longu
         eurBras2*(angleBras2Middle'-angleMot2')*Bras2Finz>

-> (148) a_bras2End_plaqueBas> = -longueurBras1*angleMot2'^2*Bras2Debuty>
         + longueurBras1*angleMot2''*Bras2Debutz> + longueurBras2*(angleBras2M
         iddle'-angleMot2')^2*Bras2Finy> + longueurBras2*(angleBras2Middle''-
         angleMot2'')*Bras2Finz>

   (149) bras3End.translate(bras3Middle, -longueurBras2*Bras3Finy>)
-> (150) p_bras3Middle_bras3End> = -longueurBras2*Bras3Finy>
-> (151) v_bras3End_plaqueBas> = longueurBras1*angleMot3'*Bras3Debutz> + longu
         eurBras2*(angleBras3Middle'-angleMot3')*Bras3Finz>

-> (152) a_bras3End_plaqueBas> = -longueurBras1*angleMot3'^2*Bras3Debuty>
         + longueurBras1*angleMot3''*Bras3Debutz> + longueurBras2*(angleBras3M
         iddle'-angleMot3')^2*Bras3Finy> + longueurBras2*(angleBras3Middle''-
         angleMot3'')*Bras3Finz>

   (153) PlaqueTopo.translate(PlaqueBaso, distancePlaqueTop_x*plaqueBasx> + distancePlaqueTop_y*plaqueBasy> + hauteurPlaqueTop*plaqueBasz>)
-> (154) p_plaqueBaso_PlaqueTopo> = distancePlaqueTop_x*plaqueBasx> + distance
         PlaqueTop_y*plaqueBasy> + hauteurPlaqueTop*plaqueBasz>

-> (155) v_PlaqueTopo_plaqueBas> = distancePlaqueTop_x'*plaqueBasx> + distance
         PlaqueTop_y'*plaqueBasy> + hauteurPlaqueTop'*plaqueBasz>

-> (156) a_PlaqueTopo_plaqueBas> = distancePlaqueTop_x''*plaqueBasx> + distanc
         ePlaqueTop_y''*plaqueBasy> + hauteurPlaqueTop''*plaqueBasz>

   (157) P1Plaque.translate(PlaqueTopo, rayonDistanceAncrageEtPivot*plaqueTopy>)
-> (158) p_PlaqueTopo_P1Plaque> = rayonDistanceAncrageEtPivot*PlaqueTopy>
-> (159) v_P1Plaque_plaqueBas> = distancePlaqueTop_x'*plaqueBasx> + distancePl
         aqueTop_y'*plaqueBasy> + hauteurPlaqueTop'*plaqueBasz> - rayonDistanc
         eAncrageEtPivot*(sin(anglePlaqueTop_y)*anglePlaqueTop_x'+anglePlaqueT
         op_z')*PlaqueTopx> + rayonDistanceAncrageEtPivot*(anglePlaqueTop_y'*
         sin(anglePlaqueTop_z)+cos(anglePlaqueTop_y)*anglePlaqueTop_x'*cos(ang
         lePlaqueTop_z))*PlaqueTopz>

-> (160) a_P1Plaque_plaqueBas> = distancePlaqueTop_x''*plaqueBasx> + distanceP
         laqueTop_y''*plaqueBasy> + hauteurPlaqueTop''*plaqueBasz> + rayonDist
         anceAncrageEtPivot*((anglePlaqueTop_y'*sin(anglePlaqueTop_z)+cos(angl
         ePlaqueTop_y)*anglePlaqueTop_x'*cos(anglePlaqueTop_z))*(anglePlaqueTo
         p_y'*cos(anglePlaqueTop_z)-cos(anglePlaqueTop_y)*anglePlaqueTop_x'*sin
         (anglePlaqueTop_z))-cos(anglePlaqueTop_y)*anglePlaqueTop_x'*anglePlaq
         ueTop_y'-sin(anglePlaqueTop_y)*anglePlaqueTop_x''-anglePlaqueTop_z'')*PlaqueTopx>
         - rayonDistanceAncrageEtPivot*((anglePlaqueTop_y'*sin(anglePlaqueTop_z)
         +cos(anglePlaqueTop_y)*anglePlaqueTop_x'*cos(anglePlaqueTop_z))^2+(sin
         (anglePlaqueTop_y)*anglePlaqueTop_x'+anglePlaqueTop_z')^2)*PlaqueTopy>
         - rayonDistanceAncrageEtPivot*(sin(anglePlaqueTop_y)*anglePlaqueTop_x'
         *anglePlaqueTop_y'*cos(anglePlaqueTop_z)+cos(anglePlaqueTop_y)*angleP
         laqueTop_x'*sin(anglePlaqueTop_z)*anglePlaqueTop_z'-anglePlaqueTop_y''
         *sin(anglePlaqueTop_z)-cos(anglePlaqueTop_y)*anglePlaqueTop_x''*cos(
         anglePlaqueTop_z)-anglePlaqueTop_y'*cos(anglePlaqueTop_z)*anglePlaque
         Top_z'-(anglePlaqueTop_y'*cos(anglePlaqueTop_z)-cos(anglePlaqueTop_y)*
         anglePlaqueTop_x'*sin(anglePlaqueTop_z))*(sin(anglePlaqueTop_y)*angle
         PlaqueTop_x'+anglePlaqueTop_z'))*PlaqueTopz>

   (161) P2Plaque.translate(PlaqueTopo,rayonDistanceAncrageEtPivot*cosDegrees(30)*plaqueTopx> - rayonDistanceAncrageEtPivot*sinDegrees(30)*plaqueTopy>)	
-> (162) p_PlaqueTopo_P2Plaque> = 0.8660254*rayonDistanceAncrageEtPivot*PlaqueTopx> - 0.5*rayonDistanceAncrageEtPivot*PlaqueTopy>

-> (163) v_P2Plaque_plaqueBas> = distancePlaqueTop_x'*plaqueBasx> + distancePl
         aqueTop_y'*plaqueBasy> + hauteurPlaqueTop'*plaqueBasz> + 0.5*rayonDis
         tanceAncrageEtPivot*(sin(anglePlaqueTop_y)*anglePlaqueTop_x'+anglePla
         queTop_z')*PlaqueTopx> + 0.8660254*rayonDistanceAncrageEtPivot*(sin(
         anglePlaqueTop_y)*anglePlaqueTop_x'+anglePlaqueTop_z')*PlaqueTopy>
         + 0.5*rayonDistanceAncrageEtPivot*(1.732051*cos(anglePlaqueTop_y)*ang
         lePlaqueTop_x'*sin(anglePlaqueTop_z)-1.732051*anglePlaqueTop_y'*cos(
         anglePlaqueTop_z)-anglePlaqueTop_y'*sin(anglePlaqueTop_z)-cos(anglePl
         aqueTop_y)*anglePlaqueTop_x'*cos(anglePlaqueTop_z))*PlaqueTopz>

-> (164) a_P2Plaque_plaqueBas> = distancePlaqueTop_x''*plaqueBasx> + distanceP
         laqueTop_y''*plaqueBasy> + hauteurPlaqueTop''*plaqueBasz> - 0.5*rayon
         DistanceAncrageEtPivot*(1.732051*(sin(anglePlaqueTop_y)*anglePlaqueTo
         p_x'+anglePlaqueTop_z')^2-cos(anglePlaqueTop_y)*anglePlaqueTop_x'*ang
         lePlaqueTop_y'-sin(anglePlaqueTop_y)*anglePlaqueTop_x''-(anglePlaqueT
         op_y'*cos(anglePlaqueTop_z)-cos(anglePlaqueTop_y)*anglePlaqueTop_x'*
         sin(anglePlaqueTop_z))*(1.732051*cos(anglePlaqueTop_y)*anglePlaqueTop
         _x'*sin(anglePlaqueTop_z)-1.732051*anglePlaqueTop_y'*cos(anglePlaqueT
         op_z)-anglePlaqueTop_y'*sin(anglePlaqueTop_z)-cos(anglePlaqueTop_y)*
         anglePlaqueTop_x'*cos(anglePlaqueTop_z))-anglePlaqueTop_z'')*PlaqueTopx>
         - 0.5*rayonDistanceAncrageEtPivot*((anglePlaqueTop_y'*sin(anglePlaque
         Top_z)+cos(anglePlaqueTop_y)*anglePlaqueTop_x'*cos(anglePlaqueTop_z))*
         (1.732051*cos(anglePlaqueTop_y)*anglePlaqueTop_x'*sin(anglePlaqueTop_z)
         -1.732051*anglePlaqueTop_y'*cos(anglePlaqueTop_z)-anglePlaqueTop_y'*
         sin(anglePlaqueTop_z)-cos(anglePlaqueTop_y)*anglePlaqueTop_x'*cos(ang
         lePlaqueTop_z))-1.732051*cos(anglePlaqueTop_y)*anglePlaqueTop_x'*angl
         ePlaqueTop_y'-1.732051*sin(anglePlaqueTop_y)*anglePlaqueTop_x''-(sin(
         anglePlaqueTop_y)*anglePlaqueTop_x'+anglePlaqueTop_z')^2-1.732051*ang
         lePlaqueTop_z'')*PlaqueTopy> + 0.5*rayonDistanceAncrageEtPivot*(sin(
         anglePlaqueTop_y)*anglePlaqueTop_x'*anglePlaqueTop_y'*cos(anglePlaque
         Top_z)+1.732051*cos(anglePlaqueTop_y)*anglePlaqueTop_x''*sin(anglePla
         queTop_z)+1.732051*anglePlaqueTop_y'*sin(anglePlaqueTop_z)*anglePlaqu
         eTop_z'+cos(anglePlaqueTop_y)*anglePlaqueTop_x'*sin(anglePlaqueTop_z)*
         anglePlaqueTop_z'+1.732051*cos(anglePlaqueTop_y)*anglePlaqueTop_x'*cos
         (anglePlaqueTop_z)*anglePlaqueTop_z'-1.732051*anglePlaqueTop_y''*cos(
         anglePlaqueTop_z)-anglePlaqueTop_y''*sin(anglePlaqueTop_z)-cos(angleP
         laqueTop_y)*anglePlaqueTop_x''*cos(anglePlaqueTop_z)-1.732051*sin(ang
         lePlaqueTop_y)*anglePlaqueTop_x'*anglePlaqueTop_y'*sin(anglePlaqueTop
         _z)-anglePlaqueTop_y'*cos(anglePlaqueTop_z)*anglePlaqueTop_z'-(angleP
         laqueTop_y'*cos(anglePlaqueTop_z)-1.732051*anglePlaqueTop_y'*sin(angl
         ePlaqueTop_z)-1.732051*cos(anglePlaqueTop_y)*anglePlaqueTop_x'*cos(an
         glePlaqueTop_z)-cos(anglePlaqueTop_y)*anglePlaqueTop_x'*sin(anglePlaq
         ueTop_z))*(sin(anglePlaqueTop_y)*anglePlaqueTop_x'+anglePlaqueTop_z'))*PlaqueTopz>

   (165) P3Plaque.translate(PlaqueTopo,-rayonDistanceAncrageEtPivot*cosDegrees(30)*plaqueTopx> - rayonDistanceAncrageEtPivot*sinDegrees(30)*plaqueTopy>)
-> (166) p_PlaqueTopo_P3Plaque> = -0.8660254*rayonDistanceAncrageEtPivot*PlaqueTopx> - 0.5*rayonDistanceAncrageEtPivot*PlaqueTopy>

-> (167) v_P3Plaque_plaqueBas> = distancePlaqueTop_x'*plaqueBasx> + distancePl
         aqueTop_y'*plaqueBasy> + hauteurPlaqueTop'*plaqueBasz> + 0.5*rayonDis
         tanceAncrageEtPivot*(sin(anglePlaqueTop_y)*anglePlaqueTop_x'+anglePla
         queTop_z')*PlaqueTopx> - 0.8660254*rayonDistanceAncrageEtPivot*(sin(
         anglePlaqueTop_y)*anglePlaqueTop_x'+anglePlaqueTop_z')*PlaqueTopy>
         + 0.5*rayonDistanceAncrageEtPivot*(1.732051*anglePlaqueTop_y'*cos(ang
         lePlaqueTop_z)-anglePlaqueTop_y'*sin(anglePlaqueTop_z)-1.732051*cos(
         anglePlaqueTop_y)*anglePlaqueTop_x'*sin(anglePlaqueTop_z)-cos(anglePl
         aqueTop_y)*anglePlaqueTop_x'*cos(anglePlaqueTop_z))*PlaqueTopz>

-> (168) a_P3Plaque_plaqueBas> = distancePlaqueTop_x''*plaqueBasx> + distanceP
         laqueTop_y''*plaqueBasy> + hauteurPlaqueTop''*plaqueBasz> + 0.5*rayon
         DistanceAncrageEtPivot*(cos(anglePlaqueTop_y)*anglePlaqueTop_x'*angle
         PlaqueTop_y'+sin(anglePlaqueTop_y)*anglePlaqueTop_x''+(anglePlaqueTop
         _y'*cos(anglePlaqueTop_z)-cos(anglePlaqueTop_y)*anglePlaqueTop_x'*sin(
         anglePlaqueTop_z))*(1.732051*anglePlaqueTop_y'*cos(anglePlaqueTop_z)-
         anglePlaqueTop_y'*sin(anglePlaqueTop_z)-1.732051*cos(anglePlaqueTop_y)
         *anglePlaqueTop_x'*sin(anglePlaqueTop_z)-cos(anglePlaqueTop_y)*angleP
         laqueTop_x'*cos(anglePlaqueTop_z))+1.732051*(sin(anglePlaqueTop_y)*an
         glePlaqueTop_x'+anglePlaqueTop_z')^2+anglePlaqueTop_z'')*PlaqueTopx>
         + 0.5*rayonDistanceAncrageEtPivot*((sin(anglePlaqueTop_y)*anglePlaque
         Top_x'+anglePlaqueTop_z')^2-1.732051*cos(anglePlaqueTop_y)*anglePlaqu
         eTop_x'*anglePlaqueTop_y'-1.732051*sin(anglePlaqueTop_y)*anglePlaqueT
         op_x''-(anglePlaqueTop_y'*sin(anglePlaqueTop_z)+cos(anglePlaqueTop_y)*
         anglePlaqueTop_x'*cos(anglePlaqueTop_z))*(1.732051*anglePlaqueTop_y'*
         cos(anglePlaqueTop_z)-anglePlaqueTop_y'*sin(anglePlaqueTop_z)-1.732051
         *cos(anglePlaqueTop_y)*anglePlaqueTop_x'*sin(anglePlaqueTop_z)-cos(an
         glePlaqueTop_y)*anglePlaqueTop_x'*cos(anglePlaqueTop_z))-1.732051*ang
         lePlaqueTop_z'')*PlaqueTopy> - 0.5*rayonDistanceAncrageEtPivot*(angle
         PlaqueTop_y''*sin(anglePlaqueTop_z)+cos(anglePlaqueTop_y)*anglePlaque
         Top_x''*cos(anglePlaqueTop_z)+1.732051*cos(anglePlaqueTop_y)*anglePla
         queTop_x''*sin(anglePlaqueTop_z)+anglePlaqueTop_y'*cos(anglePlaqueTop
         _z)*anglePlaqueTop_z'+1.732051*anglePlaqueTop_y'*sin(anglePlaqueTop_z)
         *anglePlaqueTop_z'+1.732051*cos(anglePlaqueTop_y)*anglePlaqueTop_x'*
         cos(anglePlaqueTop_z)*anglePlaqueTop_z'-1.732051*anglePlaqueTop_y''*
         cos(anglePlaqueTop_z)-1.732051*sin(anglePlaqueTop_y)*anglePlaqueTop_x'
         *anglePlaqueTop_y'*sin(anglePlaqueTop_z)-sin(anglePlaqueTop_y)*angleP
         laqueTop_x'*anglePlaqueTop_y'*cos(anglePlaqueTop_z)-cos(anglePlaqueTo
         p_y)*anglePlaqueTop_x'*sin(anglePlaqueTop_z)*anglePlaqueTop_z'-(cos(
         anglePlaqueTop_y)*anglePlaqueTop_x'*sin(anglePlaqueTop_z)-1.732051*an
         glePlaqueTop_y'*sin(anglePlaqueTop_z)-anglePlaqueTop_y'*cos(anglePlaq
         ueTop_z)-1.732051*cos(anglePlaqueTop_y)*anglePlaqueTop_x'*cos(anglePl
         aqueTop_z))*(sin(anglePlaqueTop_y)*anglePlaqueTop_x'+anglePlaqueTop_z'))*PlaqueTopz>

   (169) %--------------------------------------------------------------------
   (170) %   Motion constraints (if any).
   (171) contrainte[1] = bras1End.GetPosition(PlaqueBaso)-P1Plaque.GetPosition(PlaqueBaso)
-> (172) contrainte[1] = longueurBras1*Bras1Debuty> - longueurBras2*Bras1Finy>
         + (hauteurAxeMoteur-hauteurPlaqueTop)*mot1z> - distancePlaqueTop_x*plaqueBasx>
         + (rayonDistanceMoteur-distancePlaqueTop_y)*plaqueBasy> - rayonDistanceAncrageEtPivot*PlaqueTopy>

   (173) contrainte[2] = bras2End.GetPosition(PlaqueBaso)-P2Plaque.GetPosition(PlaqueBaso)
-> (174) contrainte[2] = longueurBras1*Bras2Debuty> - longueurBras2*Bras2Finy>
         + (hauteurAxeMoteur-hauteurPlaqueTop)*mot2z> + (0.8660254*rayonDistan
         ceMoteur-distancePlaqueTop_x)*plaqueBasx> + (-0.5*rayonDistanceMoteur-
         distancePlaqueTop_y)*plaqueBasy> - 0.8660254*rayonDistanceAncrageEtPi
         vot*PlaqueTopx> + 0.5*rayonDistanceAncrageEtPivot*PlaqueTopy>

   (175) contrainte[3] = bras3End.GetPosition(PlaqueBaso)-P3Plaque.GetPosition(PlaqueBaso)
-> (176) contrainte[3] = longueurBras1*Bras3Debuty> - longueurBras2*Bras3Finy>
         + (hauteurAxeMoteur-hauteurPlaqueTop)*mot3z> + (-0.8660254*rayonDista
         nceMoteur-distancePlaqueTop_x)*plaqueBasx> + (-0.5*rayonDistanceMoteur
         -distancePlaqueTop_y)*plaqueBasy> + 0.8660254*rayonDistanceAncrageEtP
         ivot*PlaqueTopx> + 0.5*rayonDistanceAncrageEtPivot*PlaqueTopy>

   (177) MotionConstraint[1] = dot(contrainte[1],plaqueBasx>)
-> (178) MotionConstraint[1] = rayonDistanceAncrageEtPivot*cos(anglePlaqueTop_y)
         *sin(anglePlaqueTop_z) - distancePlaqueTop_x

   (179) MotionConstraint[2] = dot(contrainte[1],plaqueBasy>)
-> (180) MotionConstraint[2] = rayonDistanceMoteur + longueurBras1*cos(angleMot1)
         - distancePlaqueTop_y - longueurBras2*cos(angleBras1Middle-angleMot1)
         - rayonDistanceAncrageEtPivot*(cos(anglePlaqueTop_x)*cos(anglePlaqueT
         op_z)-sin(anglePlaqueTop_x)*sin(anglePlaqueTop_y)*sin(anglePlaqueTop_z))

   (181) MotionConstraint[3] = dot(contrainte[1],plaqueBasz>)
-> (182) MotionConstraint[3] = hauteurAxeMoteur + longueurBras1*sin(angleMot1)
         + longueurBras2*sin(angleBras1Middle-angleMot1) - hauteurPlaqueTop
         - rayonDistanceAncrageEtPivot*(sin(anglePlaqueTop_x)*cos(anglePlaqueT
         op_z)+sin(anglePlaqueTop_y)*cos(anglePlaqueTop_x)*sin(anglePlaqueTop_z))

   (183) MotionConstraint[4] = dot(contrainte[2],plaqueBasx>)
-> (184) MotionConstraint[4] = 0.8660254*rayonDistanceMoteur + 0.8660254*longu
         eurBras1*cos(angleMot2) - distancePlaqueTop_x - 0.8660254*longueurBra
         s2*cos(angleBras2Middle-angleMot2) - 0.8660254*rayonDistanceAncrageEt
         Pivot*cos(anglePlaqueTop_y)*cos(anglePlaqueTop_z) - 0.5*rayonDistance
         AncrageEtPivot*cos(anglePlaqueTop_y)*sin(anglePlaqueTop_z)

   (185) MotionConstraint[5] = dot(contrainte[2],plaqueBasy>)
-> (186) MotionConstraint[5] = 0.5*longueurBras2*cos(angleBras2Middle-angleMot2)
         + 0.5*rayonDistanceAncrageEtPivot*(cos(anglePlaqueTop_x)*cos(anglePla
         queTop_z)-sin(anglePlaqueTop_x)*sin(anglePlaqueTop_y)*sin(anglePlaque
         Top_z)) - 0.5*rayonDistanceMoteur - distancePlaqueTop_y - 0.5*longueu
         rBras1*cos(angleMot2) - 0.8660254*rayonDistanceAncrageEtPivot*(cos(an
         glePlaqueTop_x)*sin(anglePlaqueTop_z)+sin(anglePlaqueTop_x)*sin(angle
         PlaqueTop_y)*cos(anglePlaqueTop_z))

   (187) MotionConstraint[6] = dot(contrainte[2],plaqueBasz>)
-> (188) MotionConstraint[6] = hauteurAxeMoteur + longueurBras1*sin(angleMot2)
         + longueurBras2*sin(angleBras2Middle-angleMot2) + 0.5*rayonDistanceAn
         crageEtPivot*(sin(anglePlaqueTop_x)*cos(anglePlaqueTop_z)+sin(anglePl
         aqueTop_y)*cos(anglePlaqueTop_x)*sin(anglePlaqueTop_z)) - hauteurPlaqueTop
         - 0.8660254*rayonDistanceAncrageEtPivot*(sin(anglePlaqueTop_x)*sin(an
         glePlaqueTop_z)-sin(anglePlaqueTop_y)*cos(anglePlaqueTop_x)*cos(angle
         PlaqueTop_z))

   (189) MotionConstraint[7] = dot(contrainte[3],plaqueBasx>)
-> (190) MotionConstraint[7] = 0.8660254*longueurBras2*cos(angleBras3Middle-an
         gleMot3) + 0.8660254*rayonDistanceAncrageEtPivot*cos(anglePlaqueTop_y)
         *cos(anglePlaqueTop_z) - 0.8660254*rayonDistanceMoteur - distancePlaqueTop_x
         - 0.8660254*longueurBras1*cos(angleMot3) - 0.5*rayonDistanceAncrageEt
         Pivot*cos(anglePlaqueTop_y)*sin(anglePlaqueTop_z)

   (191) MotionConstraint[8] = dot(contrainte[3],plaqueBasy>)
-> (192) MotionConstraint[8] = 0.5*longueurBras2*cos(angleBras3Middle-angleMot3)
         + 0.8660254*rayonDistanceAncrageEtPivot*(cos(anglePlaqueTop_x)*sin(an
         glePlaqueTop_z)+sin(anglePlaqueTop_x)*sin(anglePlaqueTop_y)*cos(angle
         PlaqueTop_z)) + 0.5*rayonDistanceAncrageEtPivot*(cos(anglePlaqueTop_x)
         *cos(anglePlaqueTop_z)-sin(anglePlaqueTop_x)*sin(anglePlaqueTop_y)*sin
         (anglePlaqueTop_z)) - 0.5*rayonDistanceMoteur - distancePlaqueTop_y
         - 0.5*longueurBras1*cos(angleMot3)

   (193) MotionConstraint[9] = dot(contrainte[3],plaqueBasz>)
-> (194) MotionConstraint[9] = hauteurAxeMoteur + longueurBras1*sin(angleMot3)
         + longueurBras2*sin(angleBras3Middle-angleMot3) + 0.5*rayonDistanceAn
         crageEtPivot*(sin(anglePlaqueTop_x)*cos(anglePlaqueTop_z)+sin(anglePl
         aqueTop_y)*cos(anglePlaqueTop_x)*sin(anglePlaqueTop_z)) + 0.8660254*
         rayonDistanceAncrageEtPivot*(sin(anglePlaqueTop_x)*sin(anglePlaqueTop
         _z)-sin(anglePlaqueTop_y)*cos(anglePlaqueTop_x)*cos(anglePlaqueTop_z))
         - hauteurPlaqueTop

   (195) %MotionConstraint[10] = getAngleBetweenVector(mot1y>, Bras1Debuty>)+getAngleBetweenVector(Bras1Debuty>, Bras1Finy>)+getAngleBetweenVector(Bras1Finy>, axeMot1.GetUnitVector(bras1end))-180*convertunits(deg, rad)
   (196) %MotionConstraint[11] = getAngleBetweenVector(mot2y>, Bras2Debuty>)+getAngleBetweenVector(Bras2Debuty>, Bras2Finy>)+getAngleBetweenVector(Bras2Finy>, axeMot2.GetUnitVector(bras2end))-180*convertunits(deg, rad)
   (197) %MotionConstraint[12] = getAngleBetweenVector(mot3y>, Bras3Debuty>)+getAngleBetweenVector(Bras3Debuty>, Bras3Finy>)+getAngleBetweenVector(Bras3Finy>, axeMot3.GetUnitVector(bras3end))-180*convertunits(deg, rad)
   (198) %--------------------------------------------------------------------
   (199) %   Add relevant contact/distance forces.
   (200) %chargeAppliquerSurPlaque.AddForce(-Bras3Debut*masseCharge*Az>)
   (201) %pause
   (202) %--------------------------------------------------------------------
   (203) %--------------------------------------------------------------------
   (204) %   Solve algebraic equations for list of unknowns.
   (205) %Solve( [Dynamics;motionconstraint],qA'',qB'',X'',Fx,Fz,Fwx,Fwz )
   (206) % 1= positionPlaqueInputAngleMoteurOutput
   (207) % 2= positionAngleMoteurInputPlaqueOutput
   (208) % on veut avoir comme reponse hauteurPlaqueTop, anglePlaqueTop_x et anglePlaqueTop_y
   (209) %output angleMot1 deg, angleMot2 deg, angleMot3 deg
   (210) input anglePlaqueTop_x = 0 deg, anglePlaqueTop_y = 10 deg, hauteurPlaqueTop = 92.35 mm
   (211) 	
